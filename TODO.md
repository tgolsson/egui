# TODO

TODO-list for the Egui project. If you looking for something to do, look here.

## Layout refactor

* Test `allocate_ui`
* Mix wrapping text and other widgets.

## Misc

* Widgets
  * [ ] Tooltips:
    * [ ] Tooltip widget: Something that looks like this:  (?)  :that shows text on hover.
      * [ ] ui.info_button().on_hover_text("More info here");
    * [ ] Allow adding multiple tooltips to the same widget, showing them all one after the other.
  * [ ] Vertical slider
  * [/] Color picker
    * [ ] Additive blending aware color picker
    * [ ] Premultiplied alpha is a bit of a pain in the ass. Maybe rethink this a bit.
    * [ ] Hue wheel
* Input
  * [ ] Support all mouse buttons
  * [ ] Distinguish between touch input and mouse input
* Text
  * [/] Unicode
    * [/] Text editing of unicode (needs more testing)
    * [ ] Font with some more unicode characters
  * [ ] Emoji support (great for things like ‚ñ∂Ô∏è‚è∏‚èπ‚ö†Ô∏é)
  * [ ] Change text style/color and continue in same layout
* Menu bar (File, Edit, etc)
  * [ ] Sub-menus
  * [ ] Keyboard shortcuts
* Layout
  * [ ] Table with resizable columns
  * [ ] Grid layout
  * [ ] Point list
* Windows
  * [ ] Positioning preference: `window.preference(Top, Right)`
    * [ ] Keeping right/bottom on expand. Maybe cover jitteryness with quick animation?
  * [ ] Make auto-positioning of windows respect permanent side-bars.
* Visuals
  * [ ] Fix alpha blending / sRGB weirdness in WebGL (EXT_sRGB)
  * [ ] Thin circles look bad
  * [ ] Optimize small filled circles with the global texture.
* Id
  * struct TempId(u64); struct StateId(u64);
    * `TempId` is count-based. Only good for interaction. Can't be used for storing state.
    * `StateId` must be generated from e.g. label (window title, ...), and is required for storing state (window position, ...).
    * Both can be conveted to `Id` which is used for temporary stuff like interactions and animations.
    * An `Ui`:s has two seed ids: one state, one temp. State is ONLY generated by `StateId`, no polution. A new `Ui` region is either created with e.g. a label to generate a new child `StateId`, or the region inherits the same id as the parent (but different `TempId` seed).
* Demo
  * Manual layout example:
    * ui.child_ui_pos(pos).label("Label at specific position");
    * ui.child_ui_rect(rect).label("Label in a rectangle");
* Reactive mode
  * [ ] Ask Egui if an event requires repainting
  * [ ] Only repaint when mouse is over a Egui window (or is pressed and there is an active widget)

## Integrations

### egui_web

* [x] Scroll input
* [x] Change to resize cursor on hover
* [x] Port most code to Rust
* [x] Read url fragment and redirect to a subpage (e.g. different examples apps)]
* [x] Copy/paste support
* [x] Async HTTP requests
* [x] Repaint on completed fetch request (etc)
* [ ] Local storage of app state
* [ ] Fix WebGL colors/blending (try EXT_sRGB)
* [ ] Embeddability
  * [ ] Support canvas that does NOT cover entire screen.
  * [ ] Support multiple eguis in one web page.
  * [ ] Filtering events to avoid too frequent repaints
  * [ ] Multiple canvases from the same rust code
    * Different Egui instances, same app
    * Allows very nice web integration

### Other

* [ ] Extract egui::app as own library (egui_framework ?)
* [ ] egui_bitmap: slow reference rasterizer for tests
  * Port https://github.com/emilk/imgui_software_renderer
  * Less important: fast rasterizer for embedded ü§∑‚Äç‚ôÄÔ∏è
* [ ] egui_terminal (think ncurses)
  * [ ] replace `round_to_pixel` with `round_to_X` where user can select X to be e.g. width of a letter
* [ ] egui_svg: No idea what this would be for :)


## Modularity

* [x] `trait Widget` (`Label`, `Slider`, `Checkbox`, ...)
* [ ] `trait Wrapper` (`Frame`, `Resize`, `ScrollArea`, ...)
* [ ] `widget::TextButton` implemented as a `wrapper::Button` which wraps a `widget::Label`.
* [ ] Easily chain `Wrapper`s without nested closures.
  * e.g. `ui.wrap(Frame::new()).wrap(Resize::new()).wrap(ScrollArea::new()).show(|ui| ...)`
* [ ] Attach labels to checkboxes, radio buttons and sliders with a separate wrapper-widget ?

## Other

* [x] Persist UI state in external storage
* [x] Persist Example App state
* [ ] Create an Egui icon (or use an emoji)
* [ ] Build in a profiler which tracks which `Ui` in which window takes up CPU.
  * [ ] Draw as flame graph
  * [ ] Draw as hotmap
  * [ ] Integrate puffin?
* [ ] Implement a minimal markdown viewer

## Names and structure

* [ ] Put everything in `Context` behind the same Mutex? `struct Context(Arc<Mutex<ContextImpl>>);`, with e.g. `context.lock().memory.foo`?
* [ ] Resolve the various uses of "heading", "header", "title" etc

## Global widget search

Ability to do a search for any widget. The search works even for collapsed regions and closed windows and menus. This is implemented like this: while searching, all region are layed out and their add_content functions are run. If none of the contents matches the search, the layout is reverted and nothing is shown. So windows will get temporarily opened and run, but if the search is not a match in the window it is closed again. This means then when searching your whole GUI is being run, which may be a bit slower, but it would be a really awesome feature.

## Done

* Widgets
  * [x] Label
  * [x] Button
  * [x] Checkbox
  * [x] Radiobutton
  * [x] Collapsing header region
  * [x] Tooltip
  * [x] Movable/resizable windows
  * [x] Add support for clicking hyperlinks
  * [/] Color picker
* [x] Text input
  * [x] Input
  * [x] Text focus
  * [x] Cursor movement
  * [x] Text selection
  * [x] Clipboard copy/paste
  * [x] Move focus with tab
  * [x] Text edit undo
* Containers
  * [x] Vertical slider
    * [x] Resize any side and corner on windows
    * [x] Fix autoshrink
    * [x] Automatic positioning of new windows
  * [x] Vertical scroll areas
    * [x] Scroll-wheel input
    * [x] Drag background to scroll
    * [x] Kinetic scrolling
* Simple animations
* Clip rects
  * [x] Separate Ui::clip_rect from Ui::rect
  * [x] Use clip rectangles when painting
  * [x] Use clip rectangles when interacting
  * [x] Adjust clip rects so edges of child widgets aren't clipped
  * [x] Use HW clip rects
* [x] Image support
  * [x] Show user textures
  * [x] API for creating a texture managed by `egui::app::Backend`
